---
title: 'Providers'
description: 'Supply data to agents'
---

## What are Providers?

Providers supply data and context to agents - like current time, user information, or external data.

## Provider Structure

```typescript
const provider: Provider = {
  name: 'PROVIDER_NAME',
  description: 'What this provider supplies',
  get: async (runtime, message, state) => {
    // Return data
    return data;
  }
};
```

## Bootstrap Providers

Every agent has these built-in providers:

- `characterProvider` - Agent's personality and config
- `timeProvider` - Current date and time
- `knowledgeProvider` - Knowledge base facts
- `recentMessagesProvider` - Recent conversation history
- `actionsProvider` - Available actions
- `factsProvider` - Stored facts from memory
- `settingsProvider` - Configuration settings

## Real Provider Examples

### Time Provider

```typescript
const timeProvider: Provider = {
  name: 'TIME',
  description: 'Current time and date',
  get: async () => {
    return {
      time: new Date().toLocaleString()
    };
  }
};
```

### Wallet Provider (from Sei plugin)

```
walletProvider - Manages wallet interactions
- Balance queries
- Portfolio tracking
- Transaction history
```

### Market Provider (from Arbitrage plugin)

```
marketProvider - Real-time market data
- Price feeds
- Arbitrage opportunities
- Market conditions
```

### Token Price Provider (from DexScreener plugin)

```
TokenPriceProvider - Token price data
- Current price in USD
- Liquidity information
- 24h volume data
- Auto-selects best pair by liquidity
```

## How Providers Work

1. Agent needs data during processing
2. Provider's `get()` method is called
3. Data is included in agent's context
4. Agent uses data to generate response

## Creating a Provider

Simple example:

```typescript
const weatherProvider: Provider = {
  name: 'WEATHER',
  description: 'Current weather conditions',
  
  get: async (runtime, message) => {
    const location = extractLocation(message.content);
    const weather = await fetchWeather(location);
    
    return {
      temperature: weather.temp,
      conditions: weather.conditions
    };
  }
};
```

With caching:

```typescript
const cachedProvider: Provider = {
  name: 'CACHED_DATA',
  cache: new Map(),
  
  get: async (runtime, message) => {
    const key = message.roomId;
    
    // Check cache
    if (cache.has(key)) {
      return cache.get(key);
    }
    
    // Fetch fresh data
    const data = await fetchData();
    cache.set(key, data);
    
    return data;
  }
};
```

## Common Provider Patterns

### Database Provider

```typescript
get: async (runtime) => {
  const memories = await runtime.databaseAdapter.getMemories({
    limit: 10
  });
  return { memories };
}
```

### API Provider

```typescript
get: async () => {
  const response = await fetch('https://api.example.com/data');
  return await response.json();
}
```

### Real-time Provider

```typescript
get: async () => {
  const socket = getWebSocket();
  const latestData = socket.getLatestData();
  return { data: latestData };
}
```

## Provider Priority

Providers can have a position to control order:

```typescript
const importantProvider: Provider = {
  name: 'IMPORTANT',
  position: -1, // High priority
  get: async () => ({ critical: 'data' })
};
```

## Best Practices

- Return consistent data structures
- Handle errors gracefully
- Cache when appropriate
- Keep data fetching fast
- Document what data is provided

## Next Steps

<CardGroup cols={2}>
  <Card title="Actions" icon="play" href="/core-concepts/plugins/actions">
    See how actions use provider data
  </Card>
  
  <Card title="Evaluators" icon="scale-balanced" href="/core-concepts/plugins/evaluators">
    Learn about response evaluation
  </Card>
</CardGroup>