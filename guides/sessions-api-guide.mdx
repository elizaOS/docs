---
title: Sessions API Guide
description: Learn how to use the enhanced Sessions API for persistent, stateful conversations with automatic timeout management and renewal capabilities
---

The Sessions API provides a way to create persistent, stateful conversations with ElizaOS agents. Unlike direct messaging, sessions maintain conversation context and state across multiple interactions with advanced features like automatic session renewal, expiration warnings, and configurable timeout policies.

## Why Use Sessions?

### Simplified Architecture - No Channel Management Required

One of the key advantages of the Sessions API is that it **eliminates the complexity of channel management**. Traditional messaging approaches require you to:

1. Create or find a server
2. Create or find a channel within that server
3. Add agents to the channel
4. Manage channel participants
5. Handle channel lifecycle (creation, deletion, cleanup)

With Sessions API, you simply:
1. Create a session with an agent
2. Send messages
3. (Optional) Configure timeout and renewal policies

That's it! The Sessions API handles all the underlying infrastructure automatically.

### Traditional Messaging Flow (Complex)
```javascript
// Traditional approach requires multiple steps
// 1. Create/find server
const server = await createServer({ name: 'My Server' });

// 2. Create/find channel
const channel = await createChannel({ 
  serverId: server.id, 
  name: 'chat-channel',
  type: 'direct'
});

// 3. Add agent to server
await addAgentToServer(server.id, agentId);

// 4. Add agent to channel
await addAgentToChannel(channel.id, agentId);

// 5. Finally send message
await sendMessage(channel.id, { content: 'Hello' });
```

### Sessions API Flow (Simple)
```javascript
// Sessions approach - just two steps
// 1. Create session (with optional timeout config)
const { sessionId } = await createSession({ 
  agentId, 
  userId,
  timeoutConfig: {
    timeoutMinutes: 30,
    autoRenew: true
  }
});

// 2. Send message
await sendSessionMessage(sessionId, { content: 'Hello' });
```

## Overview

Sessions are designed for:
- **Zero Channel Management**: No need to create servers, channels, or manage participants
- **Instant Setup**: Start conversations immediately with just agent and user IDs
- **Automatic Timeout Management**: Sessions automatically expire after periods of inactivity
- **Session Renewal**: Support for both automatic and manual session renewal
- **Expiration Warnings**: Get notified when sessions are about to expire
- **Configurable Policies**: Customize timeout, renewal, and duration limits per session or agent
- **Resource Optimization**: Automatic cleanup of expired sessions to prevent memory leaks
- **Persistent Conversations**: Maintain chat history and context across multiple messages
- **State Management**: Track conversation stage, renewal count, and expiration status
- **Multi-Platform Support**: Works across different platforms with metadata support

## Key Concepts

### Session Lifecycle

1. **Creation**: Start a new session with configurable timeout policies
2. **Active**: Send and receive messages within the session
3. **Near Expiration**: Warning state when session is about to expire
4. **Renewed**: Session lifetime extended (automatically or manually)
5. **Expired**: Session has exceeded its timeout and is no longer usable
6. **Deleted**: Session is explicitly terminated and cleaned up

### Session Timeout Configuration

Sessions support sophisticated timeout management with the following configurable parameters:

```typescript
interface SessionTimeoutConfig {
  timeoutMinutes?: number;           // Inactivity timeout (5-1440 minutes)
  autoRenew?: boolean;               // Auto-renew on activity (default: true)
  maxDurationMinutes?: number;       // Maximum total session duration
  warningThresholdMinutes?: number;  // When to trigger expiration warning
}
```

### Configuration Hierarchy

Timeout configurations follow a precedence hierarchy:
1. **Session-specific config** (highest priority) - Provided when creating session
2. **Agent-specific config** - Configured in agent settings
3. **Global defaults** (lowest priority) - System-wide defaults

Environment variables for global defaults:
- `SESSION_DEFAULT_TIMEOUT_MINUTES` (default: 30)
- `SESSION_MIN_TIMEOUT_MINUTES` (default: 5)
- `SESSION_MAX_TIMEOUT_MINUTES` (default: 1440 - 24 hours)
- `SESSION_MAX_DURATION_MINUTES` (default: 720 - 12 hours)
- `SESSION_WARNING_THRESHOLD_MINUTES` (default: 5)

## Quick Start

### Complete Example: Chat Application with Session Management

```javascript
// Initialize a chat with timeout management
async function startChat(agentId, userId) {
  const response = await fetch('/api/messaging/sessions', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ 
      agentId, 
      userId,
      timeoutConfig: {
        timeoutMinutes: 30,        // 30 minutes of inactivity
        autoRenew: true,           // Auto-renew on each message
        maxDurationMinutes: 180,   // 3 hour maximum session
        warningThresholdMinutes: 5 // Warn 5 minutes before expiry
      }
    })
  });
  
  const { sessionId, expiresAt, timeoutConfig } = await response.json();
  
  console.log(`Session expires at: ${expiresAt}`);
  console.log(`Auto-renewal: ${timeoutConfig.autoRenew ? 'enabled' : 'disabled'}`);
  
  return sessionId;
}

// Send messages with session status tracking
async function sendMessage(sessionId, message) {
  const response = await fetch(
    `/api/messaging/sessions/${sessionId}/messages`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ content: message })
    }
  );
  
  const data = await response.json();
  
  // Check session status
  if (data.sessionStatus) {
    console.log(`Session renewed: ${data.sessionStatus.wasRenewed}`);
    console.log(`Expires at: ${data.sessionStatus.expiresAt}`);
    
    if (data.sessionStatus.isNearExpiration) {
      console.warn('Session is about to expire!');
      // Optionally show warning to user or renew manually
    }
  }
  
  return data;
}

// Keep session alive with heartbeat
async function keepAlive(sessionId) {
  const response = await fetch(
    `/api/messaging/sessions/${sessionId}/heartbeat`,
    { method: 'POST' }
  );
  
  const { expiresAt, timeRemaining } = await response.json();
  console.log(`Session renewed, ${Math.floor(timeRemaining / 60000)} minutes remaining`);
  
  return response.json();
}
```

### 1. Create a Session with Timeout Configuration

```javascript
const response = await fetch('http://localhost:3000/api/messaging/sessions', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    agentId: 'your-agent-id',
    userId: 'your-user-id',
    metadata: {
      platform: 'web',
      username: 'john_doe',
    },
    timeoutConfig: {
      timeoutMinutes: 60,          // 1 hour timeout
      autoRenew: true,             // Auto-renew on activity
      maxDurationMinutes: 240,     // 4 hour max duration
      warningThresholdMinutes: 10  // Warn 10 min before expiry
    }
  })
});

const { 
  sessionId, 
  expiresAt,
  timeoutConfig 
} = await response.json();
```

### 2. Send Messages with Session Status

```javascript
const messageResponse = await fetch(
  `http://localhost:3000/api/messaging/sessions/${sessionId}/messages`,
  {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      content: 'Hello, I need help with my account',
      metadata: {
        userTimezone: 'America/New_York'
      }
    })
  }
);

const response = await messageResponse.json();
console.log(response.content); // Agent's response
console.log(response.metadata.thought); // Agent's internal reasoning

// Check session renewal status
if (response.sessionStatus) {
  console.log(`Session was renewed: ${response.sessionStatus.wasRenewed}`);
  console.log(`New expiration: ${response.sessionStatus.expiresAt}`);
  console.log(`Renewal count: ${response.sessionStatus.renewalCount}`);
  
  if (response.sessionStatus.isNearExpiration) {
    // Handle near-expiration warning
    alert('Your session is about to expire!');
  }
}
```

### 3. Retrieve Message History with Cursors

```javascript
// Initial fetch
const messagesResponse = await fetch(
  `http://localhost:3000/api/messaging/sessions/${sessionId}/messages?limit=20`,
  {
    method: 'GET',
  }
);

const { messages, hasMore, cursors } = await messagesResponse.json();

// Pagination - get older messages
if (hasMore && cursors?.before) {
  const olderMessages = await fetch(
    `/api/messaging/sessions/${sessionId}/messages?before=${cursors.before}&limit=20`
  );
}

// Get newer messages
if (cursors?.after) {
  const newerMessages = await fetch(
    `/api/messaging/sessions/${sessionId}/messages?after=${cursors.after}&limit=20`
  );
}
```

### 4. Manually Renew a Session

```javascript
// Useful when auto-renew is disabled or to extend before expiration
const renewResponse = await fetch(
  `http://localhost:3000/api/messaging/sessions/${sessionId}/renew`,
  {
    method: 'POST',
  }
);

const { 
  expiresAt, 
  timeRemaining, 
  renewalCount 
} = await renewResponse.json();

console.log(`Session renewed ${renewalCount} times`);
console.log(`New expiration: ${expiresAt}`);
console.log(`Time remaining: ${Math.floor(timeRemaining / 60000)} minutes`);
```

### 5. Update Session Timeout Configuration

```javascript
// Dynamically update timeout settings for an active session
const updateResponse = await fetch(
  `http://localhost:3000/api/messaging/sessions/${sessionId}/timeout`,
  {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      timeoutMinutes: 120,        // Extend to 2 hours
      autoRenew: false,           // Disable auto-renewal
      maxDurationMinutes: 480     // Increase max to 8 hours
    })
  }
);

const updatedSession = await updateResponse.json();
```

### 6. Keep Session Alive with Heartbeat

```javascript
// Send periodic heartbeats to keep session active
const heartbeatInterval = setInterval(async () => {
  try {
    const response = await fetch(
      `http://localhost:3000/api/messaging/sessions/${sessionId}/heartbeat`,
      { method: 'POST' }
    );
    
    const status = await response.json();
    
    if (status.isNearExpiration) {
      console.warn('Session expiring soon:', status.timeRemaining);
    }
  } catch (error) {
    console.error('Heartbeat failed:', error);
    clearInterval(heartbeatInterval);
  }
}, 5 * 60 * 1000); // Every 5 minutes

// Clean up on unmount/disconnect
// clearInterval(heartbeatInterval);
```

### 7. End a Session

```javascript
const deleteResponse = await fetch(
  `http://localhost:3000/api/messaging/sessions/${sessionId}`,
  {
    method: 'DELETE',
  }
);

const { success, message } = await deleteResponse.json();
console.log(message); // "Session {sessionId} deleted successfully"
```

## Advanced Features

### Session Information and Status

Get detailed session information including time remaining:

```javascript
const sessionInfo = await fetch(
  `/api/messaging/sessions/${sessionId}`
);

const info = await sessionInfo.json();
console.log(`Created: ${info.createdAt}`);
console.log(`Last activity: ${info.lastActivity}`);
console.log(`Expires: ${info.expiresAt}`);
console.log(`Time remaining: ${Math.floor(info.timeRemaining / 60000)} minutes`);
console.log(`Near expiration: ${info.isNearExpiration}`);
console.log(`Renewal count: ${info.renewalCount}`);
```

### Session Health Monitoring

Monitor the health of the sessions service:

```javascript
const healthResponse = await fetch('/api/messaging/sessions/health');
const { 
  status, 
  activeSessions, 
  expiringSoon,
  uptime 
} = await healthResponse.json();

console.log(`Service status: ${status}`);
console.log(`Active sessions: ${activeSessions}`);
console.log(`Sessions expiring soon: ${expiringSoon}`);
console.log(`Service uptime: ${uptime} seconds`);
```

### List All Active Sessions (Admin)

```javascript
const listResponse = await fetch('/api/messaging/sessions');
const { 
  sessions, 
  total,
  stats 
} = await listResponse.json();

console.log(`Total sessions: ${stats.totalSessions}`);
console.log(`Active: ${stats.activeSessions}`);
console.log(`Expired: ${stats.expiredSessions}`);

// Each session includes full status info
sessions.forEach(session => {
  console.log(`Session ${session.sessionId}:`);
  console.log(`  Agent: ${session.agentId}`);
  console.log(`  User: ${session.userId}`);
  console.log(`  Expires: ${session.expiresAt}`);
  console.log(`  Time remaining: ${session.timeRemaining}ms`);
});
```

## Error Handling

The Sessions API uses specific error classes for better error handling:

```javascript
try {
  const response = await fetch(`/api/messaging/sessions/${sessionId}/messages`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content: message })
  });

  if (!response.ok) {
    const error = await response.json();
    
    switch (response.status) {
      case 404:
        // Session not found
        console.error('Session not found:', error.details);
        // Create new session
        break;
        
      case 410:
        // Session expired
        console.error('Session expired at:', error.details.expiresAt);
        // Create new session or notify user
        break;
        
      case 400:
        // Validation error
        if (error.error.includes('content')) {
          console.error('Invalid message content');
        } else if (error.error.includes('metadata')) {
          console.error('Metadata too large');
        }
        break;
        
      case 422:
        // Session cannot be renewed
        console.error('Max duration reached:', error.details);
        // Must create new session
        break;
        
      default:
        console.error('Error:', error.message);
    }
  }
} catch (error) {
  console.error('Network error:', error);
}
```

## Best Practices

### 1. Session Timeout Management

- **Choose appropriate timeouts**: Short for quick interactions (15-30 min), longer for complex tasks (60-120 min)
- **Enable auto-renewal**: For active conversations to prevent interruptions
- **Set max duration limits**: Prevent sessions from running indefinitely
- **Handle expiration warnings**: Notify users before their session expires

### 2. Heartbeat Strategy

```javascript
class SessionManager {
  constructor(sessionId) {
    this.sessionId = sessionId;
    this.heartbeatInterval = null;
    this.warningShown = false;
  }
  
  startHeartbeat(intervalMs = 5 * 60 * 1000) {
    this.heartbeatInterval = setInterval(async () => {
      try {
        const response = await this.sendHeartbeat();
        
        if (response.isNearExpiration && !this.warningShown) {
          this.onExpirationWarning(response.timeRemaining);
          this.warningShown = true;
        }
        
        if (response.timeRemaining > response.timeoutConfig.warningThresholdMinutes * 60000) {
          this.warningShown = false; // Reset warning flag
        }
      } catch (error) {
        this.stopHeartbeat();
        this.onSessionLost(error);
      }
    }, intervalMs);
  }
  
  stopHeartbeat() {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
  }
  
  async sendHeartbeat() {
    const response = await fetch(
      `/api/messaging/sessions/${this.sessionId}/heartbeat`,
      { method: 'POST' }
    );
    
    if (!response.ok) {
      throw new Error(`Heartbeat failed: ${response.status}`);
    }
    
    return response.json();
  }
  
  onExpirationWarning(timeRemaining) {
    const minutes = Math.floor(timeRemaining / 60000);
    console.warn(`Session expires in ${minutes} minutes`);
    // Show UI warning to user
  }
  
  onSessionLost(error) {
    console.error('Session lost:', error);
    // Handle reconnection or create new session
  }
}
```

### 3. Handling Session Expiration

```javascript
class ResilientSessionClient {
  constructor(agentId, userId) {
    this.agentId = agentId;
    this.userId = userId;
    this.sessionId = null;
    this.sessionConfig = {
      timeoutMinutes: 30,
      autoRenew: true,
      maxDurationMinutes: 180
    };
  }
  
  async ensureSession() {
    if (!this.sessionId) {
      await this.createSession();
      return;
    }
    
    // Check if session is still valid
    try {
      const response = await fetch(`/api/messaging/sessions/${this.sessionId}`);
      
      if (!response.ok) {
        if (response.status === 404 || response.status === 410) {
          // Session not found or expired
          await this.createSession();
        }
      }
    } catch (error) {
      console.error('Session check failed:', error);
      await this.createSession();
    }
  }
  
  async createSession() {
    const response = await fetch('/api/messaging/sessions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        agentId: this.agentId,
        userId: this.userId,
        timeoutConfig: this.sessionConfig
      })
    });
    
    const data = await response.json();
    this.sessionId = data.sessionId;
    
    // Start heartbeat for new session
    this.startHeartbeat();
    
    return this.sessionId;
  }
  
  async sendMessage(content) {
    await this.ensureSession();
    
    const response = await fetch(
      `/api/messaging/sessions/${this.sessionId}/messages`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content })
      }
    );
    
    if (!response.ok && (response.status === 404 || response.status === 410)) {
      // Session was lost, recreate and retry
      await this.createSession();
      return this.sendMessage(content);
    }
    
    return response.json();
  }
}
```

### 4. Agent-Specific Configuration

Configure timeout defaults for specific agents via environment variables:

```bash
# Agent-specific settings (in agent's environment)
SESSION_TIMEOUT_MINUTES=60
SESSION_AUTO_RENEW=true
SESSION_MAX_DURATION_MINUTES=240
SESSION_WARNING_THRESHOLD_MINUTES=10
```

Or configure programmatically in the agent:

```javascript
// In agent configuration
const agentConfig = {
  name: 'CustomerServiceBot',
  settings: {
    SESSION_TIMEOUT_MINUTES: '45',
    SESSION_AUTO_RENEW: 'true',
    SESSION_MAX_DURATION_MINUTES: '180',
    SESSION_WARNING_THRESHOLD_MINUTES: '5'
  }
};
```

## Integration Examples

### React Hook with Session Management

```javascript
import { useState, useCallback, useEffect, useRef } from 'react';

function useElizaSession(agentId, userId) {
  const [sessionId, setSessionId] = useState(null);
  const [messages, setMessages] = useState([]);
  const [loading, setLoading] = useState(false);
  const [sessionStatus, setSessionStatus] = useState(null);
  const [expirationWarning, setExpirationWarning] = useState(false);
  const heartbeatInterval = useRef(null);

  const startSession = useCallback(async () => {
    const response = await fetch('/api/messaging/sessions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ 
        agentId, 
        userId,
        timeoutConfig: {
          timeoutMinutes: 30,
          autoRenew: true,
          maxDurationMinutes: 120,
          warningThresholdMinutes: 5
        }
      })
    });
    
    const data = await response.json();
    setSessionId(data.sessionId);
    setSessionStatus({
      expiresAt: data.expiresAt,
      timeoutConfig: data.timeoutConfig
    });
    
    // Start heartbeat
    startHeartbeat(data.sessionId);
    
    return data.sessionId;
  }, [agentId, userId]);

  const startHeartbeat = useCallback((sid) => {
    if (heartbeatInterval.current) {
      clearInterval(heartbeatInterval.current);
    }
    
    heartbeatInterval.current = setInterval(async () => {
      try {
        const response = await fetch(
          `/api/messaging/sessions/${sid}/heartbeat`,
          { method: 'POST' }
        );
        
        const status = await response.json();
        setSessionStatus(status);
        setExpirationWarning(status.isNearExpiration);
        
      } catch (error) {
        console.error('Heartbeat failed:', error);
      }
    }, 60000); // Every minute
  }, []);

  const sendMessage = useCallback(async (content) => {
    if (!sessionId) {
      const newSessionId = await startSession();
      setSessionId(newSessionId);
    }
    
    setLoading(true);
    try {
      const response = await fetch(
        `/api/messaging/sessions/${sessionId}/messages`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content })
        }
      );
      
      if (!response.ok) {
        if (response.status === 404 || response.status === 410) {
          // Session expired, create new one
          const newSessionId = await startSession();
          setSessionId(newSessionId);
          // Retry with new session
          return sendMessage(content);
        }
        throw new Error(`Failed to send message: ${response.status}`);
      }
      
      const message = await response.json();
      setMessages(prev => [...prev, message]);
      
      // Update session status if provided
      if (message.sessionStatus) {
        setSessionStatus(message.sessionStatus);
        setExpirationWarning(message.sessionStatus.isNearExpiration);
      }
      
      return message;
    } finally {
      setLoading(false);
    }
  }, [sessionId, startSession]);
  
  const renewSession = useCallback(async () => {
    if (!sessionId) return;
    
    const response = await fetch(
      `/api/messaging/sessions/${sessionId}/renew`,
      { method: 'POST' }
    );
    
    const status = await response.json();
    setSessionStatus(status);
    setExpirationWarning(false);
    
    return status;
  }, [sessionId]);

  useEffect(() => {
    // Cleanup heartbeat on unmount
    return () => {
      if (heartbeatInterval.current) {
        clearInterval(heartbeatInterval.current);
      }
    };
  }, []);

  return { 
    sessionId, 
    messages, 
    sendMessage, 
    loading,
    sessionStatus,
    expirationWarning,
    renewSession
  };
}
```

### WebSocket Integration with Session Management

```javascript
import { io } from 'socket.io-client';

class SessionWebSocketClient {
  constructor(serverUrl) {
    this.socket = io(serverUrl);
    this.sessionId = null;
    this.setupEventHandlers();
  }
  
  setupEventHandlers() {
    // Session expiration warning via WebSocket
    this.socket.on('sessionExpirationWarning', (data) => {
      if (data.sessionId === this.sessionId) {
        console.warn(`Session expires in ${data.minutesRemaining} minutes`);
        this.onExpirationWarning?.(data);
      }
    });
    
    // Session expired notification
    this.socket.on('sessionExpired', (data) => {
      if (data.sessionId === this.sessionId) {
        console.error('Session has expired');
        this.onSessionExpired?.(data);
        this.sessionId = null;
      }
    });
    
    // Session renewed notification
    this.socket.on('sessionRenewed', (data) => {
      if (data.sessionId === this.sessionId) {
        console.log('Session renewed until:', data.expiresAt);
        this.onSessionRenewed?.(data);
      }
    });
  }
  
  joinSession(sessionId) {
    this.sessionId = sessionId;
    this.socket.emit('join', { 
      roomId: sessionId,
      type: 'session'
    });
  }
  
  leaveSession() {
    if (this.sessionId) {
      this.socket.emit('leave', { 
        roomId: this.sessionId 
      });
      this.sessionId = null;
    }
  }
}
```

## Troubleshooting

### Common Issues

1. **Session Not Found (404)**
   - Session may have expired or been deleted
   - Create a new session and retry
   - Check session ID format

2. **Session Expired (410)**
   - Session exceeded its timeout period
   - Check the `expiresAt` timestamp in error details
   - Create a new session or adjust timeout configuration

3. **Cannot Renew Session (422)**
   - Session has reached maximum duration limit
   - Check `maxDurationMinutes` configuration
   - Must create a new session

4. **Invalid Timeout Configuration (400)**
   - Timeout values outside allowed range (5-1440 minutes)
   - Check configuration values against limits
   - Adjust to valid ranges

5. **Agent Not Available**
   - Ensure the agent is started and running
   - Check agent logs for errors
   - Verify agent ID is correct

### Debugging

Enable debug logging:

```javascript
const response = await fetch('/api/messaging/sessions', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'X-Debug': 'true'  // Enable debug info in response
  },
  body: JSON.stringify({ 
    agentId, 
    userId,
    // Debug mode may include additional session state info
  })
});
```

Check session cleanup logs:
```bash
# Server logs will show cleanup activity
[Sessions API] Cleanup cycle completed: 3 expired sessions removed, 2 warnings issued
[Sessions API] Session renewed via heartbeat: session-123
[Sessions API] Session abc-123 has reached maximum duration
```

## When to Use Sessions vs Traditional Messaging

### Use Sessions When:
- **Building chat interfaces**: Web apps, mobile apps, or any UI with a chat component
- **Direct user-to-agent conversations**: One-on-one interactions between a user and an agent
- **Simplified integration**: You want to get up and running quickly without infrastructure complexity
- **Stateful conversations**: You need the agent to maintain context throughout the conversation
- **Session management required**: You need timeout, renewal, and expiration handling
- **Resource optimization**: You want automatic cleanup of inactive conversations
- **Personal assistants**: Building AI assistants that remember user preferences and conversation history

### Use Traditional Messaging When:
- **Multi-agent coordination**: Multiple agents need to communicate in the same channel
- **Group conversations**: Multiple users and agents interacting together
- **Platform integrations**: Integrating with Discord, Slack, or other platforms that have their own channel concepts
- **Broadcast scenarios**: One agent sending messages to multiple channels/users
- **Complex routing**: Custom message routing logic between different channels and servers
- **Permanent history**: You need conversations to persist indefinitely without timeout

## API Reference

For complete API documentation, see:
- [Create Session](/api-reference/messaging/create-session)
- [Get Session Info](/api-reference/messaging/get-session)
- [Send Message](/api-reference/messaging/send-session-message)
- [Get Messages](/api-reference/messaging/get-session-messages)
- [Renew Session](/api-reference/messaging/renew-session)
- [Update Timeout](/api-reference/messaging/update-session-timeout)
- [Send Heartbeat](/api-reference/messaging/session-heartbeat)
- [End Session](/api-reference/messaging/end-session)
- [List Sessions](/api-reference/messaging/list-sessions)
- [Health Check](/api-reference/messaging/sessions-health-check)